# The interview process

## False negatives are acceptable.
## Problem solving skills are valuable
## Basic data structure and algorithm knowledge is useful
## Whiteboards let you focus on what matters
## But it's not for everyone or every company or every situation

# Before the interview

## Getting the right experience
### Take the big project classes: seek out the classes with big coding project
### Get an intership: Do everything you can to land an internship early in school.
### Start something: Build a project on your own times, participate in hackathons or contribute to any open source
project.
### Shift work responsibilities more towards coding:  without revealing to your manager that you are thinking of leaving
### Use your nights and weekends: If you have some free time, use it to build a application

## Writing a great resume

### Appropriate resume length
- More experienced candidates can often justify 1.5 - 2 pages otherwise
- Long resumes are not a reflaction of having ton of experience; They are reflection of not understanding how to
  prioritize content
### Employment history
- For each role, try to discuss your accomplishments with the following approach: Accomplishments X by implementing Y
  which led to Z
### Projects
- The projects should include your 2 - 4 most significant project. State what the project was which languages or
  technologies it employed
- Do not add too many projects
### Programming languages and software
- Software: Be conservative about what softwarr you list and understand what's appropirate for the company.
- Languages:
  - Listing everything you've worked with is dangerous
  - List most of the languages you've used but add your experience level
    Languages: Java (expert}, C ++ (proficient), JavaScript (prior experience).
## Advice for Non-Native English speaker and Internationals
Some companies will throw out your resume just because of a typo. Please get at least one native English speaker to
proofread your resume
### Beware of (Potential) Stigma
  - Enterprise languages: Certain languages have a stigma associated with them and those are often the ones that are
    used for enterprise
  - Being too language focused: When recruters at some of the top tech company see resumes that list every flavor of
    Jave on there resume, they make negative assumptions about the caliber of candidate
  - Certifications: Certitification for software engineers can be anything from a positive to a neutral to a negative
  - Knowing only one or Two language: The more time you've spent coding the more things you've built the more languages
    you will have tended to work with

## Preparation Map
1 + years(before interview) -> build projects outside of work -> learn multiple programming language -> expand network
-> Build website portfolio showcasing your experience -> Focus work on meaty project -> 3 - 12 months -> Continue to
work on projects. Try to add one more project -> Create draft of resume and send it out for a resume review -> Make
target list of preferred companies -> Read intro sections of CtCi -> learn and master Big O -> Implement data structures
and algoriithms from scratch -> form mock interview group with friends to interview each other. -> 1 - 3 months -> do
mini projects to solidfy understanding of key concepts -> Do serveral mock interviews -> continue to practice interview
question -> create list to track mistakes you've mde solving problems -> 4 weeks -> create interview prep grid(below) ->
Review update resume -> Begin applying to companies

### Create interview prep grid
Re-read intro to CtCi especially Tech and behavioral section -> Do another mock interview -> continues to practice
questions, writing code on paper -> 1 Weed -> Phone interview: Locate headset and/or video camera -> do a final mock
interview -> Rehearse storyes -> re-read the algorithm approaches  -> re-read Big O section -> continue to practice
interview questions -> Day before -> Rehearse each story from interview prep grid once -> Continue to practice questions
and review your list of mistakes -> review powers of 2 table(page 61). print on a phone screen -> Day of -> Wake up in
plenty of time to eate a good breakfast and be on time -> be confident -> Remember to talk out loud. Show how you think
-> Don't forget stumbling and Struggling is normal - After -> Write thank you note to recruiter -> if you haven't heard
from recruiter check in after one week -> if no offer, ask when can re-apply don't give up hope! -> get an offer?
Celebrate

## Behavioral questions

### Interview preparation grid
Go through each of the projects or components of your resume and ensure that you can talk about them in details.
Sample: https://docs.google.com/spreadsheets/d/13K6DyX1eBVv0ctQZV2Fr5rheuCCCYNJC1ZAfGKxSjdY/edit?usp=sharing
- What are your weaknesses?
  A good answer conveys a real, legitimate weakness but emphasize how you work to overcome it
  > Sometimes I don't have a very good attention to details. While that's good because it lets me execute quickly, it
  > also means that I sometimes make carless misstakes. Because of that, I make sure to always have someone else double
  > check my work
- What question should you ask the interviewer?
  - What is the ratio of testers to developers to program managers? What is the interaction like? How does project
    planning happen on the team?
  - What brought you to this company? what has been most challenging for you?
  - I noticed that you use technology X. How do you handle problem Y?
  - Why did the project choose to use X protocol over the Y protocol? I know it has benefits like A, B, C but many
    companies choose not to use it because of issue D?
  - I'm very interested in scalability, and I'd love to learn more about it. What opportunities are there at this
    company to learn about this?
  - I'm not familar with technology X, but it sounds like a very interesting solution. Could you tell me a bit more
    about how it works?
- Know your technical project
  - The project had challenging components
  - You played a central role
  - You can talk at technical depth
### Responding to Behavioral questions
  - Be specific, not Arrogant
  - Focus on yourselft, not your team
  - Give structured answers
    S.A.R situation, action result: The SAR approach means that you start off outlining the situation, then explaining the
    actions you took and lastly describing the result.
    - Situation:
    - Action:
    - Result:
  - Think about what it says
    - Initiative/Leadership: The candidate tried to resolve the situation by addressing it head-on
    - Empathy: the candidate tried to understand what was happening to the person.
    - Compassion:  Although the teamate was harming the team, the candidate wasn't angry at the teammate
    - Humility: The candidate was able to admit to his own flaws
    - Teamwork/Helpfulness: The canddate worked with the teammate to break down the project into manageable chunks
### So, Tell me about your self
    - Structure
      - Current role - headline only: I'm software engineer at EH, where I've been an intermediate SE for 2 years
      - College: My background is in information system. I did my undergrad at international universisty HCMC.
      - Post college & onwards: After college I wanted to get some exposure to international corporations so I joined SCS as
      a fullstack developer. It was great experience. I learned a ton about larger system, intergration and I got to
      really drive the launch of a key part of AWS. That actually showed me that I really wanted to be in a more.
      - Current role (Details): One of my friend introduce me to EH. Here, I did some projects related to learning
        managerment system, feature managerment, document managerments - mostly doing Ruby and React which bring many
        value to the company. My role is intermediate SE: coding, memtoring, project planing
      - Outside of work: I've been participating in some algorithm courses, building new thing and
        gaining knowledge
      - Wrap up: I'm looking now for something new, your company caught my eye. I've always loved the connection with the
        user.
    Hobbies:
      - Often they're just fluff. If your hobby is just generic activities like Skiing or playing with your dog, you can
        probably skip it
      - The hobby is extremely unique
      - The hobby is technical
      - The hobby demonstrates a possitive personality

# Big O
  Big O time is the language and metric we use to describe the efficiency of algorithms
## Time complexity
  - Electron transfer: O(s) where s is the size of the file. This means that the time to transfer file increases
    linearly with the size of the files
  - Airplan transfer O(1) with respect to the size of the file. As the size of the file increase, it won't take any
    longer to get the file to your friend. The time is constant
## Space complexity
  - Time not the only thing that matters in an Algorithm. We might also care about the amount of memory or space -
    required by an algorithm
## Drop the non Dominant terms
  - O(N^2 + N) -> O(N^2)
  - O(N + log N) -> O(N)
  - O(5 * 2^n + 1000N^100) becomes O(2^n)

  O(x^2) is much worse than O(x), but it's not nearly as bad as O(2^x) or O(x!). There are lots of runtimes worse than
  O(x!) too, such as O(x^x) or O(2^x * x!)
## Multi part algorithms: Add vs. Multiply
  - if your algorithm is in the from **do this, then, when you're all done, do that** then you add the runtimes
  - if ur algorithm is in the form **do this for each time you do that** then you multiply the runtimes
## Amortized times
  [](#Drop the non dominant terms)
## Log N runtimes
  - When you see a problem where the number of elements in the problem space gets halved each times, that will likely be
    a O(log N) run time. This is the reason why finding a element in a balanced binary search tree is O(log N). With
    each comparison, we go either left or right. Half the nodes are on each side, so we cut the problem space in haft
    each time.
## Recursive runtimes
  When you have a recursive function that makes multiple calls, the runtimes will often(but not always) look like
  O(branches depth), where the branches is the number of times each recursive call branches.
